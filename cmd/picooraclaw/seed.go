package main

import (
	"fmt"
	"os"
	"time"

	"github.com/google/uuid"
	oracledb "github.com/jasperan/picooraclaw/pkg/oracle"
)

// seedDemoCmd populates Oracle with realistic demo data for demonstrations.
func seedDemoCmd() {
	cfg, err := loadConfig()
	if err != nil {
		fmt.Printf("Error loading config: %v\n", err)
		os.Exit(1)
	}

	if !cfg.Oracle.Enabled {
		fmt.Println("Oracle is not enabled in config. Set oracle.enabled = true first.")
		os.Exit(1)
	}

	fmt.Println("ðŸŒ± Seeding Oracle Database with demo data...")

	// Connect
	conn, err := oracledb.NewConnectionManager(&cfg.Oracle)
	if err != nil {
		fmt.Printf("âœ— Connection failed: %v\n", err)
		os.Exit(1)
	}
	defer conn.Close()
	fmt.Println("âœ“ Connected to Oracle Database")

	db := conn.DB()
	agentID := cfg.Oracle.AgentID

	// Create embedding service
	var embSvc *oracledb.EmbeddingService
	if cfg.Oracle.EmbeddingProvider == "api" && cfg.Oracle.EmbeddingAPIKey != "" {
		embSvc = oracledb.NewAPIEmbeddingService(db, cfg.Oracle.EmbeddingAPIBase, cfg.Oracle.EmbeddingAPIKey, cfg.Oracle.EmbeddingModel)
	} else {
		embSvc = oracledb.NewEmbeddingService(db, cfg.Oracle.ONNXModel)
	}

	// --- Memories ---
	fmt.Print("  Seeding memories...")
	memoryStore := oracledb.NewMemoryStore(db, agentID, embSvc)

	memories := []struct {
		text       string
		importance float64
		category   string
	}{
		{"User prefers Oracle Database as the primary database. They work at Oracle and prefer Oracle AI Vector Search for embeddings.", 0.9, "preference"},
		{"Go is the user's primary programming language. They use Go 1.24 and target embedded Linux devices (RISC-V, ARM64, x86_64).", 0.85, "preference"},
		{"User prefers Ollama as the open-source LLM framework for local inference. Official docs at https://docs.ollama.com/", 0.8, "preference"},
		{"IMPORTANT: Never include AI attribution (Co-Authored-By, Generated by Claude, etc.) in git commit messages.", 0.9, "preference"},
		{"User prefers to push to GitHub manually. Only commit locally, never push automatically.", 0.85, "preference"},
		{"User is interested in RAG (Retrieval-Augmented Generation) using LlamaIndex and LangChain frameworks.", 0.7, "interest"},
		{"PicoOraClaw targets ultra-lightweight binaries (~10MB RAM) for embedded Linux devices including RISC-V boards.", 0.75, "preference"},
		{"User values privacy and data sovereignty. Prefers local/on-premise solutions over cloud-dependent services.", 0.8, "preference"},
		{"PicoOraClaw workspace is at ~/.picooraclaw/workspace/ and config at ~/.picooraclaw/config.json", 0.6, "fact"},
		{"The module path is github.com/jasperan/picooraclaw, forked from sipeed/picoclaw.", 0.7, "fact"},
		{"User prefers concise communication. Keep responses short and focused on implementation.", 0.75, "preference"},
		{"For complex multi-step tasks, use multi-agent parallel workflows. Prefer parallel agents over sequential work.", 0.65, "preference"},
		{"The Oracle ONNX embedding model used is ALL_MINILM_L12_V2 for in-database vector embeddings.", 0.7, "fact"},
		{"User is interested in IoT and embedded systems, particularly RISC-V and ARM64 development boards.", 0.6, "interest"},
		{"Design docs and plan files go in docs/plans/ (gitignored). Documentation is encouraged when beneficial.", 0.55, "preference"},
	}

	memoryErrors := 0
	for _, m := range memories {
		if _, err := memoryStore.Remember(m.text, m.importance, m.category); err != nil {
			memoryErrors++
		}
	}
	if memoryErrors == 0 {
		fmt.Printf(" âœ“ %d memories stored\n", len(memories))
	} else {
		fmt.Printf(" âš  %d/%d memories stored (%d errors)\n", len(memories)-memoryErrors, len(memories), memoryErrors)
	}

	// --- State entries ---
	fmt.Print("  Seeding state entries...")
	stateStore := oracledb.NewStateStore(db, agentID)

	stateEntries := map[string]string{
		"last_channel":       "cli",
		"last_chat_id":       "repl-session",
		"user_name":          "jasperan",
		"user_timezone":      "America/Los_Angeles",
		"agent_mode":         "interactive",
		"total_conversations": "42",
		"tools_used_count":   "187",
		"last_model":         "gpt-4o-mini",
	}

	stateErrors := 0
	for k, v := range stateEntries {
		if err := stateStore.Set(k, v); err != nil {
			stateErrors++
		}
	}
	if stateErrors == 0 {
		fmt.Printf(" âœ“ %d state entries stored\n", len(stateEntries))
	} else {
		fmt.Printf(" âš  %d/%d state entries stored (%d errors)\n", len(stateEntries)-stateErrors, len(stateEntries), stateErrors)
	}

	// --- Sessions with messages ---
	fmt.Print("  Seeding sessions...")
	sessionStore := oracledb.NewSessionStore(db, agentID)

	// Session 1: CLI REPL coding assistance
	sessionStore.AddMessage("cli:repl-session", "user", "Can you help me add a new tool to PicoOraClaw for monitoring I2C bus devices?")
	sessionStore.AddMessage("cli:repl-session", "assistant", "I can help with that. The tool should implement the `tools.Tool` interface from `pkg/tools/base.go`. You'll need `Name()`, `Description()`, `Parameters()`, and `Execute()` methods. Since I2C requires hardware access, we should also implement `ContextualTool` for proper error handling. Want me to scaffold the implementation?")
	sessionStore.AddMessage("cli:repl-session", "user", "Yes, please scaffold it. Make sure it works on RISC-V Linux.")
	sessionStore.AddMessage("cli:repl-session", "assistant", "Here's the I2C bus scanner tool. It uses `/dev/i2c-*` device files which are available on RISC-V Linux. The tool scans for connected devices and returns their addresses:\n\n```go\ntype I2CScanTool struct{}\n\nfunc (t *I2CScanTool) Name() string { return \"i2c_scan\" }\n```\n\nI've kept the binary size minimal by using only the standard library's `os` and `syscall` packages. No CGO required.")

	// Session 2: Telegram quick question
	sessionStore.AddMessage("telegram:user123", "user", "What's the status of the Oracle connection?")
	sessionStore.AddMessage("telegram:user123", "assistant", "Oracle Database connection is active. Connected to the Autonomous Database with ONNX embedding model ALL_MINILM_L12_V2 loaded. Current stats: 15 memories stored, 3 active sessions, 8 state entries.")

	// Session 3: Discord with tool usage
	sessionStore.AddMessage("discord:dev-channel", "user", "Remember that the next release should include WhatsApp channel support.")
	sessionStore.AddMessage("discord:dev-channel", "assistant", "I've stored that in memory. The next release should include WhatsApp channel support. I'll bring this up when we discuss release planning.")
	sessionStore.AddMessage("discord:dev-channel", "user", "What do you recall about our deployment targets?")
	sessionStore.AddMessage("discord:dev-channel", "assistant", "Based on my memories, your deployment targets include:\n1. Embedded Linux devices (RISC-V, ARM64, x86_64)\n2. Ultra-lightweight binaries (~10MB RAM)\n3. Self-contained single executable\n4. Oracle AI Database as optional backend\n\nThe primary focus is on resource-constrained IoT devices.")

	sessionErrors := 0
	for _, key := range []string{"cli:repl-session", "telegram:user123", "discord:dev-channel"} {
		if err := sessionStore.Save(key); err != nil {
			sessionErrors++
		}
	}
	if sessionErrors == 0 {
		fmt.Println(" âœ“ 3 sessions stored")
	} else {
		fmt.Printf(" âš  %d/3 sessions stored (%d errors)\n", 3-sessionErrors, sessionErrors)
	}

	// --- Daily notes ---
	fmt.Print("  Seeding daily notes...")
	dailyNoteErrors := 0

	// Today's note via AppendToday
	if err := memoryStore.AppendToday("## Development Progress\n- Implemented seed-demo command for Oracle data population\n- Tested vector embeddings with ALL_MINILM_L12_V2 model\n- Fixed session serialization edge case with empty tool calls"); err != nil {
		dailyNoteErrors++
	}

	// Yesterday and day before via raw SQL (AppendToday only works for SYSDATE)
	yesterday := time.Now().AddDate(0, 0, -1).Format("2006-01-02")
	dayBefore := time.Now().AddDate(0, 0, -2).Format("2006-01-02")

	yesterdayContent := fmt.Sprintf("# %s\n\n## Testing & Debugging\n- Ran full test suite: all 47 tests passing\n- Profiled memory usage on RISC-V board: 8.2MB peak\n- Verified Oracle connection pooling under concurrent load", yesterday)
	dayBeforeContent := fmt.Sprintf("# %s\n\n## Architecture Planning\n- Designed transcript storage schema for PICO_TRANSCRIPTS table\n- Sketched WhatsApp channel adapter following existing Telegram pattern\n- Reviewed LangChain-OracleDB integration for RAG pipeline", dayBefore)

	noteID1 := uuid.New().String()[:8]
	noteID2 := uuid.New().String()[:8]

	_, err = db.Exec(`
		MERGE INTO PICO_DAILY_NOTES n
		USING (SELECT :1 AS note_id FROM DUAL) src
		ON (n.agent_id = :2 AND n.note_date = TRUNC(SYSDATE) - 1)
		WHEN NOT MATCHED THEN
			INSERT (note_id, agent_id, note_date, content)
			VALUES (:3, :4, TRUNC(SYSDATE) - 1, :5)
		WHEN MATCHED THEN
			UPDATE SET content = :6, updated_at = CURRENT_TIMESTAMP
	`, noteID1, agentID, noteID1, agentID, yesterdayContent, yesterdayContent)
	if err != nil {
		dailyNoteErrors++
	}

	_, err = db.Exec(`
		MERGE INTO PICO_DAILY_NOTES n
		USING (SELECT :1 AS note_id FROM DUAL) src
		ON (n.agent_id = :2 AND n.note_date = TRUNC(SYSDATE) - 2)
		WHEN NOT MATCHED THEN
			INSERT (note_id, agent_id, note_date, content)
			VALUES (:3, :4, TRUNC(SYSDATE) - 2, :5)
		WHEN MATCHED THEN
			UPDATE SET content = :6, updated_at = CURRENT_TIMESTAMP
	`, noteID2, agentID, noteID2, agentID, dayBeforeContent, dayBeforeContent)
	if err != nil {
		dailyNoteErrors++
	}

	if dailyNoteErrors == 0 {
		fmt.Println(" âœ“ 3 daily notes stored")
	} else {
		fmt.Printf(" âš  %d/3 daily notes stored (%d errors)\n", 3-dailyNoteErrors, dailyNoteErrors)
	}

	// --- Config entries ---
	fmt.Print("  Seeding config entries...")
	configStore := oracledb.NewConfigStore(db, agentID)

	configJSON := `{
  "llm": {"provider": "openai-compatible", "model": "gpt-4o-mini", "base_url": "http://localhost:11434/v1"},
  "oracle": {"enabled": true, "onnx_model": "ALL_MINILM_L12_V2"},
  "channels": {"telegram": {"enabled": true}, "discord": {"enabled": true}},
  "agent": {"max_tool_iterations": 10, "context_window": 8192}
}`

	configErrors := 0
	if err := configStore.SetConfigValue("full_config", configJSON); err != nil {
		configErrors++
	}
	if err := configStore.SetConfigValue("last_seed", time.Now().Format(time.RFC3339)); err != nil {
		configErrors++
	}
	if configErrors == 0 {
		fmt.Println(" âœ“ 2 config entries stored")
	} else {
		fmt.Printf(" âš  %d/2 config entries stored (%d errors)\n", 2-configErrors, configErrors)
	}

	// --- Transcripts ---
	fmt.Print("  Seeding transcripts...")
	transcripts := []struct {
		sessionKey string
		seqNum     int
		role       string
		content    string
	}{
		{"cli:repl-session", 1, "user", "Can you help me add a new tool to PicoOraClaw for monitoring I2C bus devices?"},
		{"cli:repl-session", 2, "assistant", "I can help with that. The tool should implement the tools.Tool interface from pkg/tools/base.go."},
		{"telegram:user123", 1, "user", "What's the status of the Oracle connection?"},
		{"telegram:user123", 2, "assistant", "Oracle Database connection is active. Connected to the Autonomous Database with ONNX embedding model ALL_MINILM_L12_V2 loaded."},
		{"discord:dev-channel", 1, "user", "Remember that the next release should include WhatsApp channel support."},
		{"discord:dev-channel", 2, "assistant", "I've stored that in memory. The next release should include WhatsApp channel support."},
	}

	transcriptErrors := 0
	for _, t := range transcripts {
		_, err := db.Exec(`
			INSERT INTO PICO_TRANSCRIPTS (session_key, agent_id, sequence_num, role, content)
			VALUES (:1, :2, :3, :4, :5)`,
			t.sessionKey, agentID, t.seqNum, t.role, t.content,
		)
		if err != nil {
			transcriptErrors++
		}
	}
	if transcriptErrors == 0 {
		fmt.Printf(" âœ“ %d transcripts stored\n", len(transcripts))
	} else {
		fmt.Printf(" âš  %d/%d transcripts stored (%d errors)\n", len(transcripts)-transcriptErrors, len(transcripts), transcriptErrors)
	}

	fmt.Println("\nðŸŽ‰ Demo data seeded! Run 'picooraclaw oracle-inspect' to see the populated dashboard.")
}
